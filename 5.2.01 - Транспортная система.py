'''Задача: "Транспортная система"

Легенда: Вы работаете в компании, которая разрабатывает программу для
управления парком транспортных средств. Вам нужно спроектировать иерархию
классов для разных видов транспорта.

Техническое задание:

Вам необходимо создать три класса: Vehicle (Транспортное средство),
Car (Автомобиль) и Bicycle (Велосипед).
1. Базовый класс Vehicle

Это будет родительский класс для всех транспортных средств.

    Атрибуты:

        Атрибут класса vehicles_created: должен быть счетчиком, который
        будет увеличиваться каждый раз, когда создается ЛЮБОЕ транспортное
        средство (и Vehicle, и Car, и Bicycle).

        Атрибуты экземпляра (создаются в __init__):

            brand (марка)

            _max_speed (максимальная скорость). Этот атрибут должен быть
            защищенным.

            _mileage (пробег). Этот атрибут тоже должен быть защищенным.
            Начальное значение пробега всегда 0.

    Методы:

        __init__(self, brand, max_speed): Конструктор, который принимает
        марку и максимальную скорость, присваивает их атрибутам и увеличивает счетчик vehicles_created.

        get_max_speed(self): Геттер для _max_speed.

        get_mileage(self): Геттер для _mileage.

        drive(self, distance): Публичный метод, который "проезжает" указанное
        расстояние. Он должен увеличивать защищенный атрибут _mileage на величину distance.

        display_info(self): Метод, который выводит в консоль информацию в формате:
        codeCode

        Марка: [brand]
        Макс. скорость: [_max_speed] км/ч
        Пробег: [_mileage] км




2. Дочерний класс Car

Этот класс должен наследовать от Vehicle.

    Наследование: Car является потомком Vehicle.

    Атрибуты:

        __init__(self, brand, max_speed, engine_type): Конструктор должен
        принимать те же параметры, что и родитель, плюс engine_type
        (тип двигателя, например, "Бензин" или "Электро").

        Не забудьте правильно вызвать родительский __init__ с помощью super(),
        чтобы не дублировать код!

    Методы:

        Переопределите метод display_info(self). Он должен сначала вызвать
        родительскую версию этого метода с помощью super(), а затем дополнительно вывести строку:
        codeCode

        Тип двигателя: [engine_type]




3. Дочерний класс Bicycle

Этот класс также должен наследовать от Vehicle.

    Наследование: Bicycle является потомком Vehicle.

    Атрибуты:

        __init__(self, brand, max_speed, frame_material): Конструктор должен
        принимать те же параметры, что и родитель, плюс frame_material
        (материал рамы, например, "Сталь" или "Карбон").

        Используйте super() для вызова родительского конструктора.

    Методы:

        Переопределите метод display_info(self). Он также должен сначала
        вызвать родительскую версию, а затем дополнительно вывести строку:

        Материал рамы: [frame_material]




Проверочный код (Полиморфизм в действии)

После того как вы напишете все три класса, создайте следующий проверочный код.
Если ваша реализация верна, он должен отработать без ошибок и вывести ожидаемый результат.
( В САМОМ РЕШЕНИЕ ЭТОТ ДОБАВОЧНЫЙ КОД ПИСАТЬ НЕ НУЖНО, Вам необходимо лишь создать
три класса: Vehicle (Транспортное средство), Car (Автомобиль) и Bicycle (Велосипед).)

# Создаем объекты разных классов
tesla = Car("Tesla", 250, "Электро")
bmw = Car("BMW", 280, "Бензин")
trek = Bicycle("Trek", 40, "Карбон")

# Демонстрируем полиморфизм: работаем с разными объектами через общий интерфейс
vehicles = [tesla, bmw, trek]
for vehicle in vehicles:
    print("---")
    vehicle.display_info() # Один и тот же вызов - разное поведение
    vehicle.drive(100)
    print(f"Пробег после поездки: {vehicle.get_mileage()} км")

print("\n" + "="*30)
# Демонстрируем работу атрибута класса
print(f"Всего создано транспортных средств: {Vehicle.vehicles_created}")




Ожидаемый вывод:

---
Марка: Tesla
Макс. скорость: 250 км/ч
Пробег: 0 км
Тип двигателя: Электро
Пробег после поездки: 100 км
---
Марка: BMW
Макс. скорость: 280 км/ч
Пробег: 0 км
Тип двигателя: Бензин
Пробег после поездки: 100 км
---
Марка: Trek
Макс. скорость: 40 км/ч
Пробег: 0 км
Материал рамы: Карбон
Пробег после поездки: 100 км

==============================
Всего создано транспортных средств: 3'''


class Vehicle:
    # Атрибут класса: счётчик созданных транспортных средств
    vehicles_created = 0

    # Конструктор экземпляра
    def __init__(self, brand, max_speed):
        self.brand = brand                    # марка транспорта
        self._max_speed = max_speed           # защищённый атрибут: макс. скорость
        self._mileage = 0                     # защищённый атрибут: пробег, начальное значение 0
        Vehicle.vehicles_created += 1         # увеличиваем счётчик при создании любого транспортного средства

    # Геттер для _max_speed
    def get_max_speed(self):
        return self._max_speed

    # Геттер для _mileage
    def get_mileage(self):
        return self._mileage

    # Метод drive: увеличивает пробег на указанное расстояние
    def drive(self, distance):
        self._mileage += distance

    # Метод выводит общую информацию о транспортном средстве
    def display_info(self):
        print(f"Марка: {self.brand}")
        print(f"Макс. скорость: {self._max_speed} км/ч")
        print(f"Пробег: {self._mileage} км")


class Car(Vehicle):
    # Конструктор класса Car: добавляет engine_type
    def __init__(self, brand, max_speed, engine_type):
        super().__init__(brand, max_speed)    # вызываем родительский конструктор
        self.engine_type = engine_type        # новый атрибут: тип двигателя

    # Переопределяем метод display_info, добавляя информацию о двигателе
    def display_info(self):
        super().display_info()                # вызываем родительский метод
        print(f"Тип двигателя: {self.engine_type}")


class Bicycle(Vehicle):
    # Конструктор класса Bicycle: добавляет frame_material
    def __init__(self, brand, max_speed, frame_material):
        super().__init__(brand, max_speed)    # вызываем родительский конструктор
        self.frame_material = frame_material  # новый атрибут: материал рамы

    # Переопределяем метод display_info, добавляя информацию о материале рамы
    def display_info(self):
        super().display_info()                # вызываем родительский метод
        print(f"Материал рамы: {self.frame_material}")


# Создаем объекты разных классов
tesla = Car("Tesla", 250, "Электро")
bmw = Car("BMW", 280, "Бензин")
trek = Bicycle("Trek", 40, "Карбон")

# Демонстрируем полиморфизм: работаем с разными объектами через общий интерфейс
vehicles = [tesla, bmw, trek]
for vehicle in vehicles:
    print("---")
    vehicle.display_info() # Один и тот же вызов - разное поведение
    vehicle.drive(100)
    print(f"Пробег после поездки: {vehicle.get_mileage()} км")

print("\n" + "="*30)
# Демонстрируем работу атрибута класса
print(f"Всего создано транспортных средств: {Vehicle.vehicles_created}")