''''Финальная задача №3: "Иерархия Персонажей в Игре"

Легенда: Вы создаете классы для персонажей в компьютерной игре.
Вам нужна иерархия для обычных воинов и магов.

Техническое задание:

    Базовый класс Character (Персонаж):

        Атрибуты:

            name (имя) — публичный.

            _health (здоровье) — защищенный, начальное значение 100.

            _damage (урон) — защищенный.

        __init__(self, name, damage): Конструктор для установки name и _damage.

        Методы:

            attack(self, target): Метод атаки. Если у target есть метод
            take_damage, вызывает его, передавая self._damage.

            take_damage(self, amount): Уменьшает self._health на amount.

            get_status(self): Возвращает строку "Имя: [name], Здоровье: [_health]".

    Дочерний класс Warrior (Воин):

        Наследование: Наследует от Character.

        __init__(self, name, damage, armor): Конструктор, который принимает
        armor (броня) в дополнение к родительским атрибутам. Используйте super().

        Методы:

            Переопределите метод take_damage(self, amount). Логика воина
            отличается: он получает урон, уменьшенный на величину его брони
            (amount - self.armor). Урон не может быть отрицательным
            (если броня больше урона, урон равен 0).

    Дочерний класс Mage (Маг):

        Наследование: Наследует от Character.

        __init__(self, name, damage, mana): Конструктор, который принимает
        mana (мана) в дополнение к родительским атрибутам. Используйте super().

        Методы:

            Переопределите метод attack(self, target). Маг тратит 10 единиц маны
            на атаку. Если маны хватает, он вызывает родительский метод attack
            с помощью super(). Если маны не хватает, он ничего не делает.
'''


# Определение базового класса Character (Персонаж)
class Character:
    # Конструктор класса: инициализирует имя, урон и здоровье персонажа
    def __init__(self, name, damage):
        self.name = name          # Публичный атрибут: имя персонажа
        self._damage = damage     # Защищённый атрибут: наносимый урон
        self._health = 100        # Защищённый атрибут: начальное здоровье (100)

    # Метод атаки: позволяет персонажу атаковать другого персонажа
    def attack(self, target):
        # Проверяем, есть ли у цели метод take_damage (защита от некорректной цели)
        if hasattr(target, 'take_damage'):
            # Если да — вызываем метод take_damage у цели, передавая величину урона
            target.take_damage(self._damage)

    # Метод получения урона: уменьшает здоровье персонажа на указанную величину
    def take_damage(self, amount):
        self._health -= amount  # Уменьшаем здоровье на значение amount

    # Метод для получения текущего состояния персонажа
    def get_status(self):
        # Возвращает строку с именем и текущим здоровьем
        return f"Имя: {self.name}, Здоровье: {self._health}"


# Дочерний класс Warrior (Воин), наследуется от Character
class Warrior(Character):
    # Конструктор класса Warrior: принимает имя, урон и броню
    def __init__(self, name, damage, armor):
        # Вызываем конструктор родительского класса для инициализации name и _damage
        super().__init__(name, damage)
        self.armor = armor  # Добавляем новый атрибут: броня (не защищённый)

    # Переопределение метода take_damage для учёта брони
    def take_damage(self, amount):
        # Рассчитываем реальный урон: вычитаем броню из входящего урона
        # max(0, ...) гарантирует, что урон не будет отрицательным
        actual_damage = max(0, amount - self.armor)
        # Передаём рассчитанный урон в родительский метод take_damage
        super().take_damage(actual_damage)


# Дочерний класс Mage (Маг), наследуется от Character
class Mage(Character):
    # Конструктор класса Mage: принимает имя, урон и начальную ману
    def __init__(self, name, damage, mana):
        # Вызываем родительский конструктор для инициализации name и _damage
        super().__init__(name, damage)
        self.mana = mana  # Новый атрибут: количество маны

    # Переопределение метода attack, чтобы учитывать затраты маны
    def attack(self, target):
        # Проверяем, достаточно ли маны для атаки (требуется 10 единиц)
        if self.mana >= 10:
            self.mana -= 10  # Тратим 10 единиц маны
            # Выполняем атаку через родительский метод
            super().attack(target)
        # Если маны недостаточно — ничего не делаем (маг не атакует)

# Проверочный код

# Создаем персонажей
warrior = Warrior("Конан", 15, 5) # Урон 15, Броня 5
mage = Mage("Раистлин", 20, 100) # Урон 20, Мана 100

print(warrior.get_status())
print(mage.get_status())
print("--- Битва ---")

# Маг атакует воина
mage.attack(warrior)
print(warrior.get_status()) # Воин должен получить 15 урона (20 - 5 брони)

# Воин атакует мага
warrior.attack(mage)
print(mage.get_status()) # Маг должен получить 15 урона

# Проверка логики мага
mage.mana = 5 # Устанавливаем мало маны
mage.attack(warrior)
print(warrior.get_status()) # Здоровье воина не должно измениться