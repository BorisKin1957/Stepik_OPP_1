'''Задача 5: Доступ к защищенным членам
Условие:
Дочерний класс имеет доступ не только к публичным, но и к защищенным членам
родителя.

Вам нужно:

Создать родительский класс Worker. В __init__ он должен принимать name и
position и сохранять их в защищенные атрибуты self._name и self._position.

Создать дочерний класс HRManager, который наследует от Worker.

В HRManager создать публичный метод get_employee_info(), который возвращает
строку в формате "Имя: [name], Должность: [position]". Этот метод должен получить
доступ к защищенным атрибутам _name и _position, унаследованным от родителя.'''


'''Задача 5: Доступ к защищенным членам
Условие:
Дочерний класс имеет доступ не только к публичным, но и к защищенным членам 
родителя.

Вам нужно:

Создать родительский класс Worker. В __init__ он должен принимать name и 
position и сохранять их в защищенные атрибуты self._name и self._position.

Создать дочерний класс HRManager, который наследует от Worker.

В HRManager создать публичный метод get_employee_info(), который возвращает 
строку в формате "Имя: [name], Должность: [position]". Этот метод должен получить 
доступ к защищенным атрибутам _name и _position, унаследованным от родителя.'''

class Worker:
    def __init__(self, name, position):
        self._name = name
        self._position = position

class HRManager(Worker):
    def __init__(self, name, position):
        # Вызов конструктора родительского класса для корректной инициализации защищённых атрибутов
        super().__init__(name, position)

    def get_employee_info(self):
        # Доступ к защищённым атрибутам _name и _position разрешён в дочернем классе
        return f"Имя: {self._name}, Должность: {self._position}"

# Пример использования:
manager = HRManager("Анна", "HR-менеджер")
print(manager.get_employee_info())  # Имя: Анна, Должность: HR-менеджер
